class JigglyMitigator{constructor(a,b,c=null){this.options={lineDistanceThreshold:.15,longLineDistanceThreshold:.3,distanceThreshold:10,fixedDigit:2};if(null!==c)for(let d in c)null!==c[d]&&(this.options[d]=c[d]);this.strokeBufferSize=8;this.lineDistanceThreshold2=this.options.lineDistanceThreshold*this.options.lineDistanceThreshold;this.longLineDistanceThreshold2=this.options.longLineDistanceThreshold*this.options.longLineDistanceThreshold;this.distanceThreshold2=this.options.distanceThreshold*this.options.distanceThreshold;
this.strokeBuffer=[{x:a,y:b}];this.additionalPoints=[];this.temporaryPoints=[];a=this.getFixedValue(a);b=this.getFixedValue(b);this.strokePath="M"+a+" "+b+" L"+a+" "+b;this.temporaryPath=this.additionalPath="";this.lastY=this.lastX=0;this.distance=[]}appendToBuffer(a,b){if(0===this.distance.length)this.lastX=a,this.lastY=b,this.distance.push(0);else{var c=this.getDistance2(a,b,this.lastX,this.lastY);this.distance.push(Math.sqrt(c));20<this.distance.length&&this.distance.shift();c=0;for(let d=0;d<
this.distance.length;d++)c+=this.distance[d];this.strokeBufferSize=10-Math.floor(c/this.distance.length);6>this.strokeBufferSize&&(this.strokeBufferSize=6);this.lastX=a;this.lastY=b}for(this.strokeBuffer.push({x:a,y:b});this.strokeBuffer.length>this.strokeBufferSize;)this.strokeBuffer.shift();this.updateSvgPath()}getAveragePoint(a){const b=this.strokeBuffer.length;if(1===b%2||b>=this.strokeBufferSize){let c=0,d=0,e=0;for(;a<b;a++){const f=this.strokeBuffer[a];c+=f.x;d+=f.y;e++}return{x:c/e,y:d/e}}return null}updateSvgPath(){var a=
this.getAveragePoint(0);if(a){this.additionalPoints.push({x:a.x,y:a.y});this.additionalPoints=this.toSimple(this.additionalPoints);if(10<=this.additionalPoints.length)for(a=0;a<this.additionalPoints.length-10;a++){var b=this.additionalPoints[0];this.strokePath+=" L"+this.getFixedValue(b.x)+" "+this.getFixedValue(b.y);this.additionalPoints.shift()}this.additionalPath="";for(a=0;a<this.additionalPoints.length;a++)this.additionalPath+=" L"+this.getFixedValue(this.additionalPoints[a].x)+" "+this.getFixedValue(this.additionalPoints[a].y);
this.temporaryPoints.length=0;for(b=2;b<this.strokeBuffer.length;b+=2)a=this.getAveragePoint(b),this.temporaryPoints.push({x:a.x,y:a.y});this.temporaryPath="";for(a=0;a<this.temporaryPoints.length;a++)this.temporaryPath+=" L"+this.getFixedValue(this.temporaryPoints[a].x)+" "+this.getFixedValue(this.temporaryPoints[a].y);return!0}return!1}toSimple(a){for(let e=2;e<a.length-1;e++){var b=a[e-2],c=a[e-1],d=a[e];const f=a[e+1];b=this.getLinePointDistance2(c.x,c.y,b.x,b.y,d.x,d.y);const g=this.getLinePointDistance2(d.x,
d.y,c.x,c.y,f.x,f.y);g<=this.lineDistanceThreshold2&&g<b?a.splice(e--,1):(c=this.getDistance2(c.x,c.y,d.x,d.y),d=this.getDistance2(d.x,d.y,f.x,f.y),c>=this.distanceThreshold2&&d>=this.distanceThreshold2&&g<=this.longLineDistanceThreshold2&&g<b&&a.splice(e--,1))}return a}getPath(){return this.strokePath+this.additionalPath+this.temporaryPath}getFixedValue(a){return parseFloat(a.toFixed(this.options.fixedDigit))}getDistance2(a,b,c,d){return(c-a)*(c-a)+(d-b)*(d-b)}getLinePointDistance2(a,b,c,d,e,f){const g=
(f-d)*(f-d)+(e-c)*(e-c);if(0===g)return 0;a=Math.abs((f-d)*a-(e-c)*b+e*d-f*c);return a*a/g}};
